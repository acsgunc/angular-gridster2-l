import { ChangeDetectorRef, ElementRef, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges } from '@angular/core';
import { GridsterComponentInterface } from './gridster.interface';
import { GridsterCompact } from './gridsterCompact.service';
import { GridsterConfig } from './gridsterConfig.interface';
import { GridsterConfigS } from './gridsterConfigS.interface';
import { GridsterEmptyCell } from './gridsterEmptyCell.service';
import { GridsterItem } from './gridsterItem.interface';
import { GridsterItemComponentInterface } from './gridsterItemComponent.interface';
import { GridsterRenderer } from './gridsterRenderer.service';
import * as ɵngcc0 from '@angular/core';
export declare class GridsterComponent implements OnInit, OnChanges, OnDestroy, GridsterComponentInterface {
    renderer: Renderer2;
    cdRef: ChangeDetectorRef;
    zone: NgZone;
    options: GridsterConfig;
    calculateLayoutDebounce: () => void;
    movingItem: GridsterItem | null;
    previewStyle: () => void;
    el: any;
    $options: GridsterConfigS;
    mobile: boolean;
    curWidth: number;
    curHeight: number;
    grid: Array<GridsterItemComponentInterface>;
    columns: number;
    rows: number;
    curColWidth: number;
    curRowHeight: number;
    gridColumns: never[];
    gridRows: never[];
    windowResize: (() => void) | null;
    dragInProgress: boolean;
    emptyCell: GridsterEmptyCell;
    compact: GridsterCompact;
    gridRenderer: GridsterRenderer;
    constructor(el: ElementRef, renderer: Renderer2, cdRef: ChangeDetectorRef, zone: NgZone);
    checkCollisionTwoItems(item: GridsterItem, item2: GridsterItem): boolean;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    resize(): void;
    setOptions(): void;
    optionsChanged(): void;
    ngOnDestroy(): void;
    onResize(): void;
    checkIfToResize(): boolean;
    setGridSize(): void;
    setGridDimensions(): void;
    calculateLayout(): void;
    updateGrid(): void;
    addItem(itemComponent: GridsterItemComponentInterface): void;
    removeItem(itemComponent: GridsterItemComponentInterface): void;
    checkCollision(item: GridsterItem): GridsterItemComponentInterface | boolean;
    checkGridCollision(item: GridsterItem): boolean;
    findItemWithItem(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemsWithItem(item: GridsterItem): Array<GridsterItemComponentInterface>;
    autoPositionItem(itemComponent: GridsterItemComponentInterface): void;
    getNextPossiblePosition(newItem: GridsterItem, startingFrom?: {
        y?: number;
        x?: number;
    }): boolean;
    getFirstPossiblePosition(item: GridsterItem): GridsterItem;
    getLastPossiblePosition(item: GridsterItem): GridsterItem;
    pixelsToPositionX(x: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    pixelsToPositionY(y: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    positionXToPixels(x: number): number;
    positionYToPixels(y: number): number;
    static checkCollisionTwoItemsForSwaping(item: GridsterItem, item2: GridsterItem): boolean;
    checkCollisionForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemWithItemForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    private static getNewArrayLength;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<GridsterComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<GridsterComponent, "gridster", never, { "options": "options"; }, {}, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHN0ZXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImdyaWRzdGVyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIE5nWm9uZSwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHcmlkc3RlckNvbXBvbmVudEludGVyZmFjZSB9IGZyb20gJy4vZ3JpZHN0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IEdyaWRzdGVyQ29tcGFjdCB9IGZyb20gJy4vZ3JpZHN0ZXJDb21wYWN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZHN0ZXJDb25maWcgfSBmcm9tICcuL2dyaWRzdGVyQ29uZmlnLmludGVyZmFjZSc7XG5pbXBvcnQgeyBHcmlkc3RlckNvbmZpZ1MgfSBmcm9tICcuL2dyaWRzdGVyQ29uZmlnUy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgR3JpZHN0ZXJFbXB0eUNlbGwgfSBmcm9tICcuL2dyaWRzdGVyRW1wdHlDZWxsLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZHN0ZXJJdGVtIH0gZnJvbSAnLi9ncmlkc3Rlckl0ZW0uaW50ZXJmYWNlJztcbmltcG9ydCB7IEdyaWRzdGVySXRlbUNvbXBvbmVudEludGVyZmFjZSB9IGZyb20gJy4vZ3JpZHN0ZXJJdGVtQ29tcG9uZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBHcmlkc3RlclJlbmRlcmVyIH0gZnJvbSAnLi9ncmlkc3RlclJlbmRlcmVyLnNlcnZpY2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgR3JpZHN0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBHcmlkc3RlckNvbXBvbmVudEludGVyZmFjZSB7XG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgICBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgem9uZTogTmdab25lO1xuICAgIG9wdGlvbnM6IEdyaWRzdGVyQ29uZmlnO1xuICAgIGNhbGN1bGF0ZUxheW91dERlYm91bmNlOiAoKSA9PiB2b2lkO1xuICAgIG1vdmluZ0l0ZW06IEdyaWRzdGVySXRlbSB8IG51bGw7XG4gICAgcHJldmlld1N0eWxlOiAoKSA9PiB2b2lkO1xuICAgIGVsOiBhbnk7XG4gICAgJG9wdGlvbnM6IEdyaWRzdGVyQ29uZmlnUztcbiAgICBtb2JpbGU6IGJvb2xlYW47XG4gICAgY3VyV2lkdGg6IG51bWJlcjtcbiAgICBjdXJIZWlnaHQ6IG51bWJlcjtcbiAgICBncmlkOiBBcnJheTxHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2U+O1xuICAgIGNvbHVtbnM6IG51bWJlcjtcbiAgICByb3dzOiBudW1iZXI7XG4gICAgY3VyQ29sV2lkdGg6IG51bWJlcjtcbiAgICBjdXJSb3dIZWlnaHQ6IG51bWJlcjtcbiAgICBncmlkQ29sdW1uczogbmV2ZXJbXTtcbiAgICBncmlkUm93czogbmV2ZXJbXTtcbiAgICB3aW5kb3dSZXNpemU6ICgoKSA9PiB2b2lkKSB8IG51bGw7XG4gICAgZHJhZ0luUHJvZ3Jlc3M6IGJvb2xlYW47XG4gICAgZW1wdHlDZWxsOiBHcmlkc3RlckVtcHR5Q2VsbDtcbiAgICBjb21wYWN0OiBHcmlkc3RlckNvbXBhY3Q7XG4gICAgZ3JpZFJlbmRlcmVyOiBHcmlkc3RlclJlbmRlcmVyO1xuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIyLCBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHpvbmU6IE5nWm9uZSk7XG4gICAgY2hlY2tDb2xsaXNpb25Ud29JdGVtcyhpdGVtOiBHcmlkc3Rlckl0ZW0sIGl0ZW0yOiBHcmlkc3Rlckl0ZW0pOiBib29sZWFuO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgcmVzaXplKCk6IHZvaWQ7XG4gICAgc2V0T3B0aW9ucygpOiB2b2lkO1xuICAgIG9wdGlvbnNDaGFuZ2VkKCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBvblJlc2l6ZSgpOiB2b2lkO1xuICAgIGNoZWNrSWZUb1Jlc2l6ZSgpOiBib29sZWFuO1xuICAgIHNldEdyaWRTaXplKCk6IHZvaWQ7XG4gICAgc2V0R3JpZERpbWVuc2lvbnMoKTogdm9pZDtcbiAgICBjYWxjdWxhdGVMYXlvdXQoKTogdm9pZDtcbiAgICB1cGRhdGVHcmlkKCk6IHZvaWQ7XG4gICAgYWRkSXRlbShpdGVtQ29tcG9uZW50OiBHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2UpOiB2b2lkO1xuICAgIHJlbW92ZUl0ZW0oaXRlbUNvbXBvbmVudDogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlKTogdm9pZDtcbiAgICBjaGVja0NvbGxpc2lvbihpdGVtOiBHcmlkc3Rlckl0ZW0pOiBHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2UgfCBib29sZWFuO1xuICAgIGNoZWNrR3JpZENvbGxpc2lvbihpdGVtOiBHcmlkc3Rlckl0ZW0pOiBib29sZWFuO1xuICAgIGZpbmRJdGVtV2l0aEl0ZW0oaXRlbTogR3JpZHN0ZXJJdGVtKTogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlIHwgYm9vbGVhbjtcbiAgICBmaW5kSXRlbXNXaXRoSXRlbShpdGVtOiBHcmlkc3Rlckl0ZW0pOiBBcnJheTxHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2U+O1xuICAgIGF1dG9Qb3NpdGlvbkl0ZW0oaXRlbUNvbXBvbmVudDogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlKTogdm9pZDtcbiAgICBnZXROZXh0UG9zc2libGVQb3NpdGlvbihuZXdJdGVtOiBHcmlkc3Rlckl0ZW0sIHN0YXJ0aW5nRnJvbT86IHtcbiAgICAgICAgeT86IG51bWJlcjtcbiAgICAgICAgeD86IG51bWJlcjtcbiAgICB9KTogYm9vbGVhbjtcbiAgICBnZXRGaXJzdFBvc3NpYmxlUG9zaXRpb24oaXRlbTogR3JpZHN0ZXJJdGVtKTogR3JpZHN0ZXJJdGVtO1xuICAgIGdldExhc3RQb3NzaWJsZVBvc2l0aW9uKGl0ZW06IEdyaWRzdGVySXRlbSk6IEdyaWRzdGVySXRlbTtcbiAgICBwaXhlbHNUb1Bvc2l0aW9uWCh4OiBudW1iZXIsIHJvdW5kaW5nTWV0aG9kOiAoeDogbnVtYmVyKSA9PiBudW1iZXIsIG5vTGltaXQ/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIHBpeGVsc1RvUG9zaXRpb25ZKHk6IG51bWJlciwgcm91bmRpbmdNZXRob2Q6ICh4OiBudW1iZXIpID0+IG51bWJlciwgbm9MaW1pdD86IGJvb2xlYW4pOiBudW1iZXI7XG4gICAgcG9zaXRpb25YVG9QaXhlbHMoeDogbnVtYmVyKTogbnVtYmVyO1xuICAgIHBvc2l0aW9uWVRvUGl4ZWxzKHk6IG51bWJlcik6IG51bWJlcjtcbiAgICBzdGF0aWMgY2hlY2tDb2xsaXNpb25Ud29JdGVtc0ZvclN3YXBpbmcoaXRlbTogR3JpZHN0ZXJJdGVtLCBpdGVtMjogR3JpZHN0ZXJJdGVtKTogYm9vbGVhbjtcbiAgICBjaGVja0NvbGxpc2lvbkZvclN3YXBpbmcoaXRlbTogR3JpZHN0ZXJJdGVtKTogR3JpZHN0ZXJJdGVtQ29tcG9uZW50SW50ZXJmYWNlIHwgYm9vbGVhbjtcbiAgICBmaW5kSXRlbVdpdGhJdGVtRm9yU3dhcGluZyhpdGVtOiBHcmlkc3Rlckl0ZW0pOiBHcmlkc3Rlckl0ZW1Db21wb25lbnRJbnRlcmZhY2UgfCBib29sZWFuO1xuICAgIHByaXZhdGUgc3RhdGljIGdldE5ld0FycmF5TGVuZ3RoO1xufVxuIl19